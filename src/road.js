// Generated by BUCKLESCRIPT VERSION 4.0.7000, PLEASE EDIT WITH CARE
'use strict';

var List = require("bsb-native/lib/js/list.js");
var Track = require("./track.js");
var Common = require("./common.js");
var Reprocessing_Draw = require("/Users/jim/Github/returbo/node_modules/reprocessing/src/Reprocessing_Draw.js");
var Reprocessing_Utils = require("/Users/jim/Github/returbo/node_modules/reprocessing/src/Reprocessing_Utils.js");

var height = Common.height;

var width = Common.width;

var maxHeight = height / 2;

var partial_arg = Reprocessing_Utils.color(65, 65, 65, 255);

function fillDarkGrey(param) {
  return Reprocessing_Draw.fill(partial_arg, param);
}

var partial_arg$1 = Reprocessing_Utils.color(80, 80, 80, 255);

function fillLightGrey(param) {
  return Reprocessing_Draw.fill(partial_arg$1, param);
}

var partial_arg$2 = Reprocessing_Utils.color(150, 80, 80, 255);

function fillRed(param) {
  return Reprocessing_Draw.fill(partial_arg$2, param);
}

function currentDirection(state) {
  return Track.head(state[/* track */2]);
}

function moveForward(newPosition, state) {
  if (state[/* lastPiece */1] * 40 - newPosition <= 0) {
    return /* record */[
            /* position */newPosition,
            /* lastPiece */state[/* lastPiece */1] + 1 | 0,
            /* track */Track.progress(state[/* track */2])
          ];
  } else {
    return /* record */[
            /* position */newPosition,
            /* lastPiece */state[/* lastPiece */1],
            /* track */state[/* track */2]
          ];
  }
}

function onCheckpoint(state) {
  return Track.isCheckpoint(Track.head(state[/* track */2]));
}

function checkpointBonus(state) {
  var p = Track.head(state[/* track */2]);
  if (typeof p === "number" || p.tag !== 2) {
    return 0;
  } else {
    return p[0];
  }
}

function nextY(currentY) {
  if (currentY >= 320) {
    return currentY - 40;
  } else {
    var yDelta = 160 / 40;
    var revY = -(currentY - 320);
    var height = 40 - revY / yDelta;
    var match = height > 6;
    var delta = match ? height : 6;
    return currentY - delta;
  }
}

var _piFactor = 4 * Math.atan(1) / 180;

function calcDeltaX(yDistance, angle) {
  return yDistance * Math.tan(angle * _piFactor);
}

function drawRoad(_leftBottom, _rightBottom, firstHeight, _track, _goals, _isDark, env) {
  while(true) {
    var isDark = _isDark;
    var goals = _goals;
    var track = _track;
    var rightBottom = _rightBottom;
    var leftBottom = _leftBottom;
    var x1 = rightBottom[0];
    var y0 = leftBottom[1];
    var x0 = leftBottom[0];
    var trackPiece = List.hd(track);
    var isCheckpoint = Track.isCheckpoint(trackPiece);
    if (isDark) {
      fillDarkGrey(env);
    } else {
      fillLightGrey(env);
    }
    if (isCheckpoint) {
      fillRed(env);
    }
    var y1 = y0 === height ? height - 40 + firstHeight : nextY(y0);
    var curveStength;
    if (typeof trackPiece === "number") {
      curveStength = 0.0;
    } else {
      switch (trackPiece.tag | 0) {
        case 0 : 
            curveStength = -trackPiece[0];
            break;
        case 1 : 
            curveStength = trackPiece[0];
            break;
        case 2 : 
            curveStength = 0.0;
            break;
        
      }
    }
    var nextGoalL = goals[0] + ((height - y1) * curveStength | 0) | 0;
    var nextGoalR = goals[1] + ((height - y1) * curveStength | 0) | 0;
    var opposite = y0 - maxHeight;
    var adjacentL = nextGoalL - x0;
    var adjacentR = x1 - nextGoalR;
    var leftAngleRadians = Math.atan(opposite / adjacentL);
    var rightAngleRadians = Math.atan(opposite / adjacentR);
    var left = (y0 - y1) / Math.tan(leftAngleRadians);
    var right = (y0 - y1) / Math.tan(rightAngleRadians);
    var rightX = x1 - right;
    var leftX = x0 + left;
    Reprocessing_Draw.quadf(leftBottom, rightBottom, /* tuple */[
          rightX,
          y1
        ], /* tuple */[
          leftX,
          y1
        ], env);
    var isOutOfBounds = maxHeight >= y1 || x1 < 0 + Common.minOffset || x0 > width + Common.maxOffset;
    if (isOutOfBounds) {
      return /* () */0;
    } else {
      _isDark = !isDark;
      _goals = /* tuple */[
        nextGoalL,
        nextGoalR
      ];
      _track = List.tl(track);
      _rightBottom = /* tuple */[
        rightX,
        y1
      ];
      _leftBottom = /* tuple */[
        leftX,
        y1
      ];
      continue ;
    }
  };
}

function findInitialCoordinates(offset, state) {
  var adj = state[/* position */0] % (40 * 2);
  var match = adj >= 40;
  var match$1 = match ? /* tuple */[
      true,
      adj - 40
    ] : /* tuple */[
      false,
      adj
    ];
  var x0 = width / 2 - Common.roadWidth / 2 + offset;
  var x1 = width / 2 + Common.roadWidth / 2 + offset;
  return /* tuple */[
          x0,
          x1,
          match$1[1],
          match$1[0]
        ];
}

var init = /* record */[
  /* position */0,
  /* lastPiece */1,
  /* track */Track.init
];

function draw(offset, state, env) {
  var match = findInitialCoordinates(offset, state);
  var iOffset = offset * 0.4 | 0;
  var goal_000 = 244 + iOffset | 0;
  var goal_001 = 324 + iOffset | 0;
  var goal = /* tuple */[
    goal_000,
    goal_001
  ];
  return drawRoad(/* tuple */[
              match[0],
              height
            ], /* tuple */[
              match[1],
              height
            ], match[2], state[/* track */2][/* track */0], goal, match[3], env);
}

var baseWidth = Common.roadWidth;

var baseLength = 40;

exports.height = height;
exports.width = width;
exports.baseWidth = baseWidth;
exports.baseLength = baseLength;
exports.maxHeight = maxHeight;
exports.fillDarkGrey = fillDarkGrey;
exports.fillLightGrey = fillLightGrey;
exports.fillRed = fillRed;
exports.currentDirection = currentDirection;
exports.moveForward = moveForward;
exports.onCheckpoint = onCheckpoint;
exports.checkpointBonus = checkpointBonus;
exports.nextY = nextY;
exports._piFactor = _piFactor;
exports.calcDeltaX = calcDeltaX;
exports.drawRoad = drawRoad;
exports.findInitialCoordinates = findInitialCoordinates;
exports.init = init;
exports.draw = draw;
/* partial_arg Not a pure module */
